"use strict";(self.webpackChunkwei=self.webpackChunkwei||[]).push([[2914],{32914:(t,e,n)=>{n.r(e),n.d(e,{AVERAGE:()=>s,BVHShaderGLSL:()=>r,CENTER:()=>i,CONTAINED:()=>l,ExtendedTriangle:()=>rt,FloatVertexAttributeTexture:()=>Pn,INTERSECTED:()=>u,IntVertexAttributeTexture:()=>Tn,MeshBVH:()=>We,MeshBVHHelper:()=>Ze,MeshBVHUniformStruct:()=>Mn,NOT_INTERSECTED:()=>c,OrientedBox:()=>ot,SAH:()=>a,StaticGeometryGenerator:()=>Wn,UIntVertexAttributeTexture:()=>An,VertexAttributeTexture:()=>Bn,acceleratedRaycast:()=>pn,computeBatchedBoundsTree:()=>bn,computeBoundsTree:()=>xn,disposeBatchedBoundsTree:()=>vn,disposeBoundsTree:()=>gn,estimateMemoryInBytes:()=>tn,getBVHExtremes:()=>Je,getJSONStructure:()=>nn,getTriangleHitPointInfo:()=>zt,shaderDistanceFunction:()=>Qn,shaderIntersectFunction:()=>Kn,shaderStructs:()=>jn,validateBounds:()=>en});var r={};n.r(r),n.d(r,{bvh_distance_functions:()=>Ln,bvh_ray_functions:()=>Xn,bvh_struct_definitions:()=>Zn,common_functions:()=>Gn});var o=n(59464);const i=0,s=1,a=2,c=0,u=1,l=2,d=1.25,f=1,h=32,p=65535,y=Math.pow(2,-24),m=Symbol("SKIP_GENERATION");function x(t){return t.index?t.index.count:t.attributes.position.count}function g(t){return x(t)/3}function b(t,e=ArrayBuffer){return t>65535?new Uint32Array(new e(4*t)):new Uint16Array(new e(2*t))}function v(t,e){const n=g(t),r=e||t.drawRange,o=r.start/3,i=(r.start+r.count)/3,s=Math.max(0,o),a=Math.min(n,i)-s;return[{offset:Math.floor(s),count:Math.floor(a)}]}function w(t,e){if(!t.groups||!t.groups.length)return v(t,e);const n=[],r=new Set,o=e||t.drawRange,i=o.start/3,s=(o.start+o.count)/3;for(const c of t.groups){const t=c.start/3,e=(c.start+c.count)/3;r.add(Math.max(i,t)),r.add(Math.min(s,e))}const a=Array.from(r.values()).sort(((t,e)=>t-e));for(let c=0;c<a.length-1;c++){const t=a[c],e=a[c+1];n.push({offset:Math.floor(t),count:Math.floor(e-t)})}return n}function B(t,e,n,r,o){let i=1/0,s=1/0,a=1/0,c=-1/0,u=-1/0,l=-1/0,d=1/0,f=1/0,h=1/0,p=-1/0,y=-1/0,m=-1/0;for(let x=6*e,g=6*(e+n);x<g;x+=6){const e=t[x+0],n=t[x+1],r=e-n,o=e+n;r<i&&(i=r),o>c&&(c=o),e<d&&(d=e),e>p&&(p=e);const g=t[x+2],b=t[x+3],v=g-b,w=g+b;v<s&&(s=v),w>u&&(u=w),g<f&&(f=g),g>y&&(y=g);const B=t[x+4],A=t[x+5],T=B-A,P=B+A;T<a&&(a=T),P>l&&(l=P),B<h&&(h=B),B>m&&(m=B)}r[0]=i,r[1]=s,r[2]=a,r[3]=c,r[4]=u,r[5]=l,o[0]=d,o[1]=f,o[2]=h,o[3]=p,o[4]=y,o[5]=m}function A(t,e,n){return n.min.x=e[t],n.min.y=e[t+1],n.min.z=e[t+2],n.max.x=e[t+3],n.max.y=e[t+4],n.max.z=e[t+5],n}function T(t){let e=-1,n=-1/0;for(let r=0;r<3;r++){const o=t[r+3]-t[r];o>n&&(n=o,e=r)}return e}function P(t,e){e.set(t)}function M(t,e,n){let r,o;for(let i=0;i<3;i++){const s=i+3;r=t[i],o=e[i],n[i]=r<o?r:o,r=t[s],o=e[s],n[s]=r>o?r:o}}function I(t,e,n){for(let r=0;r<3;r++){const o=e[t+2*r],i=e[t+2*r+1],s=o-i,a=o+i;s<n[r]&&(n[r]=s),a>n[r+3]&&(n[r+3]=a)}}function S(t){const e=t[3]-t[0],n=t[4]-t[1],r=t[5]-t[2];return 2*(e*n+n*r+r*e)}const _=32,D=(t,e)=>t.candidate-e.candidate,q=new Array(_).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),F=new Float32Array(6);class N{constructor(){this.boundingData=new Float32Array(6)}}function U(t,e,n,r,o,i){let s=r,a=r+o-1;const c=i.pos,u=2*i.axis;for(;;){for(;s<=a&&n[6*s+u]<c;)s++;for(;s<=a&&n[6*a+u]>=c;)a--;if(!(s<a))return s;for(let t=0;t<3;t++){let n=e[3*s+t];e[3*s+t]=e[3*a+t],e[3*a+t]=n}for(let t=0;t<6;t++){let e=n[6*s+t];n[6*s+t]=n[6*a+t],n[6*a+t]=e}s++,a--}}function E(t,e,n,r,o,i){let s=r,a=r+o-1;const c=i.pos,u=2*i.axis;for(;;){for(;s<=a&&n[6*s+u]<c;)s++;for(;s<=a&&n[6*a+u]>=c;)a--;if(!(s<a))return s;{let e=t[s];t[s]=t[a],t[a]=e;for(let t=0;t<6;t++){let e=n[6*s+t];n[6*s+t]=n[6*a+t],n[6*a+t]=e}s++,a--}}}function k(t,e){return 65535===e[t+15]}function z(t,e){return e[t+6]}function R(t,e){return e[t+14]}function H(t){return t+8}function C(t,e){return e[t+6]}function V(t,e){return e[t+7]}let Y,O,W,G;const L=Math.pow(2,32);function X(t){return"count"in t?1:1+X(t.left)+X(t.right)}function Z(t,e,n){return Y=new Float32Array(n),O=new Uint32Array(n),W=new Uint16Array(n),G=new Uint8Array(n),j(t,e)}function j(t,e){const n=t/4,r=t/2,o="count"in e,i=e.boundingData;for(let s=0;s<6;s++)Y[n+s]=i[s];if(o){if(e.buffer){const r=e.buffer;G.set(new Uint8Array(r),t);for(let e=t,o=t+r.byteLength;e<o;e+=h){k(e/2,W)||(O[e/4+6]+=n)}return t+r.byteLength}{const o=e.offset,i=e.count;return O[n+6]=o,W[r+14]=i,W[r+15]=p,t+h}}{const r=e.left,o=e.right,i=e.splitAxis;let s;if(s=j(t+h,r),s/4>L)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return O[n+6]=s/4,s=j(s,o),O[n+7]=i,s}}function Q(t,e,n,r,o){const{maxDepth:c,verbose:u,maxLeafTris:l,strategy:h,onProgress:p,indirect:y}=o,m=t._indirectBuffer,x=t.geometry,b=x.index?x.index.array:null,v=y?E:U,w=g(x),A=new Float32Array(6);let k=!1;const z=new N;return B(e,n,r,z.boundingData,A),function t(n,r,o,p=null,y=0){!k&&y>=c&&(k=!0,u&&(console.warn(`MeshBVH: Max depth of ${c} reached when generating BVH. Consider increasing maxDepth.`),console.warn(x)));if(o<=l||y>=c)return R(r+o),n.offset=r,n.count=o,n;const g=function(t,e,n,r,o,c){let u=-1,l=0;if(c===i)u=T(e),-1!==u&&(l=(e[u]+e[u+3])/2);else if(c===s)u=T(t),-1!==u&&(l=function(t,e,n,r){let o=0;for(let i=e,s=e+n;i<s;i++)o+=t[6*i+2*r];return o/n}(n,r,o,u));else if(c===a){const i=S(t);let s=d*o;const a=6*r,c=6*(r+o);for(let t=0;t<3;t++){const r=e[t],h=(e[t+3]-r)/_;if(o<8){const e=[...q];e.length=o;let r=0;for(let o=a;o<c;o+=6,r++){const i=e[r];i.candidate=n[o+2*t],i.count=0;const{bounds:s,leftCacheBounds:a,rightCacheBounds:c}=i;for(let t=0;t<3;t++)c[t]=1/0,c[t+3]=-1/0,a[t]=1/0,a[t+3]=-1/0,s[t]=1/0,s[t+3]=-1/0;I(o,n,s)}e.sort(D);let h=o;for(let t=0;t<h;t++){const n=e[t];for(;t+1<h&&e[t+1].candidate===n.candidate;)e.splice(t+1,1),h--}for(let o=a;o<c;o+=6){const r=n[o+2*t];for(let t=0;t<h;t++){const i=e[t];r>=i.candidate?I(o,n,i.rightCacheBounds):(I(o,n,i.leftCacheBounds),i.count++)}}for(let n=0;n<h;n++){const r=e[n],a=r.count,c=o-r.count,h=r.leftCacheBounds,p=r.rightCacheBounds;let y=0;0!==a&&(y=S(h)/i);let m=0;0!==c&&(m=S(p)/i);const x=f+d*(y*a+m*c);x<s&&(u=t,s=x,l=r.candidate)}}else{for(let t=0;t<_;t++){const e=q[t];e.count=0,e.candidate=r+h+t*h;const n=e.bounds;for(let t=0;t<3;t++)n[t]=1/0,n[t+3]=-1/0}for(let o=a;o<c;o+=6){let e=~~((n[o+2*t]-r)/h);e>=_&&(e=31);const i=q[e];i.count++,I(o,n,i.bounds)}const e=q[31];P(e.bounds,e.rightCacheBounds);for(let t=30;t>=0;t--){const e=q[t],n=q[t+1];M(e.bounds,n.rightCacheBounds,e.rightCacheBounds)}let p=0;for(let n=0;n<31;n++){const e=q[n],r=e.count,a=e.bounds,c=q[n+1].rightCacheBounds;0!==r&&(0===p?P(a,F):M(a,F,F)),p+=r;let h=0,y=0;0!==p&&(h=S(F)/i);const m=o-p;0!==m&&(y=S(c)/i);const x=f+d*(h*p+y*m);x<s&&(u=t,s=x,l=e.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${c} used.`);return{axis:u,pos:l}}(n.boundingData,p,e,r,o,h);if(-1===g.axis)return R(r+o),n.offset=r,n.count=o,n;const w=v(m,b,e,r,o,g);if(w===r||w===r+o)R(r+o),n.offset=r,n.count=o;else{n.splitAxis=g.axis;const i=new N,s=r,a=w-r;n.left=i,B(e,s,a,i.boundingData,A),t(i,s,a,A,y+1);const c=new N,u=w,l=o-a;n.right=c,B(e,u,l,c.boundingData,A),t(c,u,l,A,y+1)}return n}(z,n,r,A),z;function R(t){p&&p(t/w)}}function K(t,e){const n=t.geometry;e.indirect&&(t._indirectBuffer=function(t,e){const n=(t.index?t.index.count:t.attributes.position.count)/3,r=n>65536,o=r?4:2,i=e?new SharedArrayBuffer(n*o):new ArrayBuffer(n*o),s=r?new Uint32Array(i):new Uint16Array(i);for(let a=0,c=s.length;a<c;a++)s[a]=a;return s}(n,e.useSharedArrayBuffer),function(t,e){const n=g(t),r=w(t,e).sort(((t,e)=>t.offset-e.offset)),o=r[r.length-1];o.count=Math.min(n-o.offset,o.count);let i=0;return r.forEach((({count:t})=>i+=t)),n!==i}(n,e.range)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),t._indirectBuffer||function(t,e){if(!t.index){const n=t.attributes.position.count,r=b(n,e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);t.setIndex(new o.THS(r,1));for(let t=0;t<n;t++)r[t]=t}}(n,e);const r=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=function(t,e=null,n=null,r=null){const o=t.attributes.position,i=t.index?t.index.array:null,s=g(t),a=o.normalized;let c;null===e?(c=new Float32Array(6*s),n=0,r=s):(c=e,n=n||0,r=r||s);const u=o.array,l=o.offset||0;let d=3;o.isInterleavedBufferAttribute&&(d=o.data.stride);const f=["getX","getY","getZ"];for(let h=n;h<n+r;h++){const t=3*h,e=6*h;let n=t+0,r=t+1,s=t+2;i&&(n=i[n],r=i[r],s=i[s]),a||(n=n*d+l,r=r*d+l,s=s*d+l);for(let i=0;i<3;i++){let t,l,d;a?(t=o[f[i]](n),l=o[f[i]](r),d=o[f[i]](s)):(t=u[n+i],l=u[r+i],d=u[s+i]);let h=t;l<h&&(h=l),d<h&&(h=d);let p=t;l>p&&(p=l),d>p&&(p=d);const m=(p-h)/2,x=2*i;c[e+x+0]=h+m,c[e+x+1]=m+(Math.abs(h)+m)*y}}return c}(n),s=e.indirect?v(n,e.range):w(n,e.range);t._roots=s.map((n=>{const o=Q(t,i,n.offset,n.count,e),s=X(o),a=new r(h*s);return Z(0,o,a),a}))}class ${constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,r=-1/0;for(let o=0,i=t.length;o<i;o++){const i=t[o][e];n=i<n?i:n,r=i>r?i:r}this.min=n,this.max=r}setFromPoints(t,e){let n=1/0,r=-1/0;for(let o=0,i=e.length;o<i;o++){const i=e[o],s=t.dot(i);n=s<n?s:n,r=s>r?s:r}this.min=n,this.max=r}isSeparated(t){return this.min>t.max||t.min>this.max}}$.prototype.setFromBox=function(){const t=new o.Pq0;return function(e,n){const r=n.min,o=n.max;let i=1/0,s=-1/0;for(let a=0;a<=1;a++)for(let n=0;n<=1;n++)for(let c=0;c<=1;c++){t.x=r.x*a+o.x*(1-a),t.y=r.y*n+o.y*(1-n),t.z=r.z*c+o.z*(1-c);const u=e.dot(t);i=Math.min(u,i),s=Math.max(u,s)}this.min=i,this.max=s}}();!function(){const t=new $}();const J=function(){const t=new o.Pq0,e=new o.Pq0,n=new o.Pq0;return function(r,o,i){const s=r.start,a=t,c=o.start,u=e;n.subVectors(s,c),t.subVectors(r.end,r.start),e.subVectors(o.end,o.start);const l=n.dot(u),d=u.dot(a),f=u.dot(u),h=n.dot(a),p=a.dot(a)*f-d*d;let y,m;y=0!==p?(l*d-h*f)/p:0,m=(l+y*d)/f,i.x=y,i.y=m}}(),tt=function(){const t=new o.I9Y,e=new o.Pq0,n=new o.Pq0;return function(r,o,i,s){J(r,o,t);let a=t.x,c=t.y;if(a>=0&&a<=1&&c>=0&&c<=1)return r.at(a,i),void o.at(c,s);if(a>=0&&a<=1)return c<0?o.at(0,s):o.at(1,s),void r.closestPointToPoint(s,!0,i);if(c>=0&&c<=1)return a<0?r.at(0,i):r.at(1,i),void o.closestPointToPoint(i,!0,s);{let t,u;t=a<0?r.start:r.end,u=c<0?o.start:o.end;const l=e,d=n;return r.closestPointToPoint(u,!0,e),o.closestPointToPoint(t,!0,n),l.distanceToSquared(u)<=d.distanceToSquared(t)?(i.copy(l),void s.copy(u)):(i.copy(t),void s.copy(d))}}}(),et=function(){const t=new o.Pq0,e=new o.Pq0,n=new o.Zcv,r=new o.cZY;return function(o,i){const{radius:s,center:a}=o,{a:c,b:u,c:l}=i;r.start=c,r.end=u;if(r.closestPointToPoint(a,!0,t).distanceTo(a)<=s)return!0;r.start=c,r.end=l;if(r.closestPointToPoint(a,!0,t).distanceTo(a)<=s)return!0;r.start=u,r.end=l;if(r.closestPointToPoint(a,!0,t).distanceTo(a)<=s)return!0;const d=i.getPlane(n);if(Math.abs(d.distanceToPoint(a))<=s){const t=d.projectPoint(a,e);if(i.containsPoint(t))return!0}return!1}}();function nt(t){return Math.abs(t)<1e-15}class rt extends o.lMl{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new o.Pq0)),this.satBounds=new Array(4).fill().map((()=>new $)),this.points=[this.a,this.b,this.c],this.sphere=new o.iyt,this.plane=new o.Zcv,this.needsUpdate=!0}intersectsSphere(t){return et(t,this)}update(){const t=this.a,e=this.b,n=this.c,r=this.points,o=this.satAxes,i=this.satBounds,s=o[0],a=i[0];this.getNormal(s),a.setFromPoints(s,r);const c=o[1],u=i[1];c.subVectors(t,e),u.setFromPoints(c,r);const l=o[2],d=i[2];l.subVectors(e,n),d.setFromPoints(l,r);const f=o[3],h=i[3];f.subVectors(n,t),h.setFromPoints(f,r),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(s,t),this.needsUpdate=!1}}rt.prototype.closestPointToSegment=function(){const t=new o.Pq0,e=new o.Pq0,n=new o.cZY;return function(r,o=null,i=null){const{start:s,end:a}=r,c=this.points;let u,l=1/0;for(let d=0;d<3;d++){const s=(d+1)%3;n.start.copy(c[d]),n.end.copy(c[s]),tt(n,r,t,e),u=t.distanceToSquared(e),u<l&&(l=u,o&&o.copy(t),i&&i.copy(e))}return this.closestPointToPoint(s,t),u=s.distanceToSquared(t),u<l&&(l=u,o&&o.copy(t),i&&i.copy(s)),this.closestPointToPoint(a,t),u=a.distanceToSquared(t),u<l&&(l=u,o&&o.copy(t),i&&i.copy(a)),Math.sqrt(l)}}(),rt.prototype.intersectsTriangle=function(){const t=new rt,e=new Array(3),n=new Array(3),r=new $,i=new $,s=new o.Pq0,a=new o.Pq0,c=new o.Pq0,u=new o.Pq0,l=new o.Pq0,d=new o.cZY,f=new o.cZY,h=new o.cZY,p=new o.Pq0;function y(t,e,n){const r=t.points;let o=0,i=-1;for(let s=0;s<3;s++){const{start:t,end:c}=d;t.copy(r[s]),c.copy(r[(s+1)%3]),d.delta(a);const u=nt(e.distanceToPoint(t));if(nt(e.normal.dot(a))&&u){n.copy(d),o=2;break}const l=e.intersectLine(d,p);if(!l&&u&&p.copy(t),(l||u)&&!nt(p.distanceTo(c))){if(o<=1){(1===o?n.start:n.end).copy(p),u&&(i=o)}else if(o>=2){(1===i?n.start:n.end).copy(p),o=2;break}if(o++,2===o&&-1===i)break}}return o}return function(o,a=null,d=!1){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(t.copy(o),t.update(),o=t);const p=this.plane,m=o.plane;if(Math.abs(p.normal.dot(m.normal))>1-1e-10){const t=this.satBounds,c=this.satAxes;n[0]=o.a,n[1]=o.b,n[2]=o.c;for(let e=0;e<4;e++){const o=t[e],i=c[e];if(r.setFromPoints(i,n),o.isSeparated(r))return!1}const u=o.satBounds,l=o.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let n=0;n<4;n++){const t=u[n],o=l[n];if(r.setFromPoints(o,e),t.isSeparated(r))return!1}for(let o=0;o<4;o++){const t=c[o];for(let o=0;o<4;o++){const a=l[o];if(s.crossVectors(t,a),r.setFromPoints(s,e),i.setFromPoints(s,n),r.isSeparated(i))return!1}}return a&&(d||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),a.start.set(0,0,0),a.end.set(0,0,0)),!0}{const t=y(this,m,f);if(1===t&&o.containsPoint(f.end))return a&&(a.start.copy(f.end),a.end.copy(f.end)),!0;if(2!==t)return!1;const e=y(o,p,h);if(1===e&&this.containsPoint(h.end))return a&&(a.start.copy(h.end),a.end.copy(h.end)),!0;if(2!==e)return!1;if(f.delta(c),h.delta(u),c.dot(u)<0){let t=h.start;h.start=h.end,h.end=t}const n=f.start.dot(c),r=f.end.dot(c),i=h.start.dot(c),s=h.end.dot(c);return(n===s||i===r||r<i!==n<s)&&(a&&(l.subVectors(f.start,h.start),l.dot(c)>0?a.start.copy(f.start):a.start.copy(h.start),l.subVectors(f.end,h.end),l.dot(c)<0?a.end.copy(f.end):a.end.copy(h.end)),!0)}}}(),rt.prototype.distanceToPoint=function(){const t=new o.Pq0;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),rt.prototype.distanceToTriangle=function(){const t=new o.Pq0,e=new o.Pq0,n=["a","b","c"],r=new o.cZY,i=new o.cZY;return function(o,s=null,a=null){const c=s||a?r:null;if(this.intersectsTriangle(o,c))return(s||a)&&(s&&c.getCenter(s),a&&c.getCenter(a)),0;let u=1/0;for(let e=0;e<3;e++){let r;const i=n[e],c=o[i];this.closestPointToPoint(c,t),r=c.distanceToSquared(t),r<u&&(u=r,s&&s.copy(t),a&&a.copy(c));const l=this[i];o.closestPointToPoint(l,t),r=l.distanceToSquared(t),r<u&&(u=r,s&&s.copy(l),a&&a.copy(t))}for(let l=0;l<3;l++){const c=n[l],d=n[(l+1)%3];r.set(this[c],this[d]);for(let l=0;l<3;l++){const c=n[l],d=n[(l+1)%3];i.set(o[c],o[d]),tt(r,i,t,e);const f=t.distanceToSquared(e);f<u&&(u=f,s&&s.copy(t),a&&a.copy(e))}}return Math.sqrt(u)}}();class ot{constructor(t,e,n){this.isOrientedBox=!0,this.min=new o.Pq0,this.max=new o.Pq0,this.matrix=new o.kn4,this.invMatrix=new o.kn4,this.points=new Array(8).fill().map((()=>new o.Pq0)),this.satAxes=new Array(3).fill().map((()=>new o.Pq0)),this.satBounds=new Array(3).fill().map((()=>new $)),this.alignedSatBounds=new Array(3).fill().map((()=>new $)),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),n&&this.matrix.copy(n)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}ot.prototype.update=function(){const t=this.matrix,e=this.min,n=this.max,r=this.points;for(let c=0;c<=1;c++)for(let o=0;o<=1;o++)for(let i=0;i<=1;i++){const s=r[1*c|2*o|4*i];s.x=c?n.x:e.x,s.y=o?n.y:e.y,s.z=i?n.z:e.z,s.applyMatrix4(t)}const o=this.satBounds,i=this.satAxes,s=r[0];for(let c=0;c<3;c++){const t=i[c],e=o[c],n=r[1<<c];t.subVectors(s,n),e.setFromPoints(t,r)}const a=this.alignedSatBounds;a[0].setFromPointsField(r,"x"),a[1].setFromPointsField(r,"y"),a[2].setFromPointsField(r,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},ot.prototype.intersectsBox=function(){const t=new $;return function(e){this.needsUpdate&&this.update();const n=e.min,r=e.max,o=this.satBounds,i=this.satAxes,s=this.alignedSatBounds;if(t.min=n.x,t.max=r.x,s[0].isSeparated(t))return!1;if(t.min=n.y,t.max=r.y,s[1].isSeparated(t))return!1;if(t.min=n.z,t.max=r.z,s[2].isSeparated(t))return!1;for(let a=0;a<3;a++){const n=i[a],r=o[a];if(t.setFromBox(n,e),r.isSeparated(t))return!1}return!0}}(),ot.prototype.intersectsTriangle=function(){const t=new rt,e=new Array(3),n=new $,r=new $,i=new o.Pq0;return function(o){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(t.copy(o),t.update(),o=t);const s=this.satBounds,a=this.satAxes;e[0]=o.a,e[1]=o.b,e[2]=o.c;for(let t=0;t<3;t++){const r=s[t],o=a[t];if(n.setFromPoints(o,e),r.isSeparated(n))return!1}const c=o.satBounds,u=o.satAxes,l=this.points;for(let t=0;t<3;t++){const e=c[t],r=u[t];if(n.setFromPoints(r,l),e.isSeparated(n))return!1}for(let t=0;t<3;t++){const o=a[t];for(let t=0;t<4;t++){const s=u[t];if(i.crossVectors(o,s),n.setFromPoints(i,e),r.setFromPoints(i,l),n.isSeparated(r))return!1}}return!0}}(),ot.prototype.closestPointToPoint=function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e},ot.prototype.distanceToPoint=function(){const t=new o.Pq0;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),ot.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map((()=>new o.cZY)),n=new Array(12).fill().map((()=>new o.cZY)),r=new o.Pq0,i=new o.Pq0;return function(o,s=0,a=null,c=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(a||c)&&(o.getCenter(i),this.closestPointToPoint(i,r),o.closestPointToPoint(r,i),a&&a.copy(r),c&&c.copy(i)),0;const u=s*s,l=o.min,d=o.max,f=this.points;let h=1/0;for(let t=0;t<8;t++){const e=f[t];i.copy(e).clamp(l,d);const n=e.distanceToSquared(i);if(n<h&&(h=n,a&&a.copy(e),c&&c.copy(i),n<u))return Math.sqrt(n)}let p=0;for(let r=0;r<3;r++)for(let o=0;o<=1;o++)for(let i=0;i<=1;i++){const s=(r+1)%3,a=(r+2)%3,c=1<<r|o<<s|i<<a,u=f[o<<s|i<<a],h=f[c];e[p].set(u,h);const y=t[r],m=t[s],x=t[a],g=n[p],b=g.start,v=g.end;b[y]=l[y],b[m]=o?l[m]:d[m],b[x]=i?l[x]:d[m],v[y]=d[y],v[m]=o?l[m]:d[m],v[x]=i?l[x]:d[m],p++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let n=0;n<=1;n++){i.x=t?d.x:l.x,i.y=e?d.y:l.y,i.z=n?d.z:l.z,this.closestPointToPoint(i,r);const o=i.distanceToSquared(r);if(o<h&&(h=o,a&&a.copy(r),c&&c.copy(i),o<u))return Math.sqrt(o)}for(let t=0;t<12;t++){const o=e[t];for(let t=0;t<12;t++){const e=n[t];tt(o,e,r,i);const s=r.distanceToSquared(i);if(s<h&&(h=s,a&&a.copy(r),c&&c.copy(i),s<u))return Math.sqrt(s)}}return Math.sqrt(h)}}();class it{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class st extends it{constructor(){super((()=>new rt))}}const at=new st;const ct=new class{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=n=>{e&&t.push(e),e=n,this.float32Array=new Float32Array(n),this.uint16Array=new Uint16Array(n),this.uint32Array=new Uint32Array(n)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,0!==t.length&&this.setBuffer(t.pop())}}};let ut,lt;const dt=[],ft=new it((()=>new o.NRn));function ht(t,e,n,r,o,i){ut=ft.getPrimitive(),lt=ft.getPrimitive(),dt.push(ut,lt),ct.setBuffer(t._roots[e]);const s=pt(0,t.geometry,n,r,o,i);ct.clearBuffer(),ft.releasePrimitive(ut),ft.releasePrimitive(lt),dt.pop(),dt.pop();const a=dt.length;return a>0&&(lt=dt[a-1],ut=dt[a-2]),s}function pt(t,e,n,r,o=null,i=0,s=0){const{float32Array:a,uint16Array:c,uint32Array:u}=ct;let d=2*t;if(k(d,c)){const f=z(t,u),h=R(d,c);return A(t,a,ut),r(f,h,!1,s,i+t,ut)}{const p=H(t),y=C(t,u);let m,x,g,b,v=p,w=y;if(o&&(g=ut,b=lt,A(v,a,g),A(w,a,b),m=o(g),x=o(b),x<m)){v=y,w=p;const _=m;m=x,x=_,g=b}g||(g=ut,A(v,a,g));const B=n(g,k(2*v,c),m,s+1,i+v);let T;if(B===l){const D=I(v);T=r(D,S(v)-D,!0,s+1,i+v,g)}else T=B&&pt(v,e,n,r,o,i,s+1);if(T)return!0;b=lt,A(w,a,b);const P=n(b,k(2*w,c),x,s+1,i+w);let M;if(P===l){const q=I(w);M=r(q,S(w)-q,!0,s+1,i+w,b)}else M=P&&pt(w,e,n,r,o,i,s+1);return!!M;function I(t){const{uint16Array:e,uint32Array:n}=ct;let r=2*t;for(;!k(r,e);)r=2*(t=H(t));return z(t,n)}function S(t){const{uint16Array:e,uint32Array:n}=ct;let r=2*t;for(;!k(r,e);)r=2*(t=C(t,n));return z(t,n)+R(r,e)}}}const yt=new o.Pq0,mt=new o.Pq0;const xt=parseInt(o.sPf)>=169,gt=new o.Pq0,bt=new o.Pq0,vt=new o.Pq0,wt=new o.I9Y,Bt=new o.I9Y,At=new o.I9Y,Tt=new o.Pq0,Pt=new o.Pq0,Mt=new o.Pq0,It=new o.Pq0;function St(t,e,n,r,i,s,a,c,u,l,d){gt.fromBufferAttribute(e,s),bt.fromBufferAttribute(e,a),vt.fromBufferAttribute(e,c);const f=function(t,e,n,r,i,s,a,c){let u;if(u=s===o.hsX?t.intersectTriangle(r,n,e,!0,i):t.intersectTriangle(e,n,r,s!==o.$EB,i),null===u)return null;const l=t.origin.distanceTo(i);return l<a||l>c?null:{distance:l,point:i.clone()}}(t,gt,bt,vt,It,u,l,d);if(f){const e=new o.Pq0;o.lMl.getBarycoord(It,gt,bt,vt,e),r&&(wt.fromBufferAttribute(r,s),Bt.fromBufferAttribute(r,a),At.fromBufferAttribute(r,c),f.uv=o.lMl.getInterpolation(It,gt,bt,vt,wt,Bt,At,new o.I9Y)),i&&(wt.fromBufferAttribute(i,s),Bt.fromBufferAttribute(i,a),At.fromBufferAttribute(i,c),f.uv1=o.lMl.getInterpolation(It,gt,bt,vt,wt,Bt,At,new o.I9Y)),n&&(Tt.fromBufferAttribute(n,s),Pt.fromBufferAttribute(n,a),Mt.fromBufferAttribute(n,c),f.normal=o.lMl.getInterpolation(It,gt,bt,vt,Tt,Pt,Mt,new o.Pq0),f.normal.dot(t.direction)>0&&f.normal.multiplyScalar(-1));const u={a:s,b:a,c:c,normal:new o.Pq0,materialIndex:0};o.lMl.getNormal(gt,bt,vt,u.normal),f.face=u,f.faceIndex=s,xt&&(f.barycoord=e)}return f}function _t(t,e,n,r,o,i,s){const a=3*r;let c=a+0,u=a+1,l=a+2;const d=t.index;t.index&&(c=d.getX(c),u=d.getX(u),l=d.getX(l));const{position:f,normal:h,uv:p,uv1:y}=t.attributes,m=St(n,f,h,p,y,c,u,l,e,i,s);return m?(m.faceIndex=r,o&&o.push(m),m):null}function Dt(t,e,n,r){const o=t.a,i=t.b,s=t.c;let a=e,c=e+1,u=e+2;n&&(a=n.getX(a),c=n.getX(c),u=n.getX(u)),o.x=r.getX(a),o.y=r.getY(a),o.z=r.getZ(a),i.x=r.getX(c),i.y=r.getY(c),i.z=r.getZ(c),s.x=r.getX(u),s.y=r.getY(u),s.z=r.getZ(u)}const qt=new o.Pq0,Ft=new o.Pq0,Nt=new o.Pq0,Ut=new o.I9Y,Et=new o.I9Y,kt=new o.I9Y;function zt(t,e,n,r){const i=e.getIndex().array,s=e.getAttribute("position"),a=e.getAttribute("uv"),c=i[3*n],u=i[3*n+1],l=i[3*n+2];qt.fromBufferAttribute(s,c),Ft.fromBufferAttribute(s,u),Nt.fromBufferAttribute(s,l);let d=0;const f=e.groups,h=3*n;for(let o=0,m=f.length;o<m;o++){const t=f[o],{start:e,count:n}=t;if(h>=e&&h<e+n){d=t.materialIndex;break}}const p=r&&r.barycoord?r.barycoord:new o.Pq0;o.lMl.getBarycoord(t,qt,Ft,Nt,p);let y=null;return a&&(Ut.fromBufferAttribute(a,c),Et.fromBufferAttribute(a,u),kt.fromBufferAttribute(a,l),y=r&&r.uv?r.uv:new o.I9Y,o.lMl.getInterpolation(t,qt,Ft,Nt,Ut,Et,kt,y)),r?(r.face||(r.face={}),r.face.a=c,r.face.b=u,r.face.c=l,r.face.materialIndex=d,r.face.normal||(r.face.normal=new o.Pq0),o.lMl.getNormal(qt,Ft,Nt,r.face.normal),y&&(r.uv=y),r.barycoord=p,r):{face:{a:c,b:u,c:l,materialIndex:d,normal:o.lMl.getNormal(qt,Ft,Nt,new o.Pq0)},uv:y,barycoord:p}}function Rt(t,e,n,r,o,i,s){const{geometry:a}=n,{index:c}=a,u=a.attributes.position;for(let l=t,d=e+t;l<d;l++){let t;if(t=l,Dt(s,3*t,c,u),s.needsUpdate=!0,r(s,t,o,i))return!0}return!1}function Ht(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const n=t.geometry,r=n.index?n.index.array:null,o=n.attributes.position;let i,s,a,c,u=0;const l=t._roots;for(let f=0,h=l.length;f<h;f++)i=l[f],s=new Uint32Array(i),a=new Uint16Array(i),c=new Float32Array(i),d(0,u),u+=i.byteLength;function d(t,n,i=!1){const u=2*t;if(a[u+15]===p){const e=s[t+6];let n=1/0,i=1/0,l=1/0,d=-1/0,f=-1/0,h=-1/0;for(let t=3*e,s=3*(e+a[u+14]);t<s;t++){let e=r[t];const s=o.getX(e),a=o.getY(e),c=o.getZ(e);s<n&&(n=s),s>d&&(d=s),a<i&&(i=a),a>f&&(f=a),c<l&&(l=c),c>h&&(h=c)}return(c[t+0]!==n||c[t+1]!==i||c[t+2]!==l||c[t+3]!==d||c[t+4]!==f||c[t+5]!==h)&&(c[t+0]=n,c[t+1]=i,c[t+2]=l,c[t+3]=d,c[t+4]=f,c[t+5]=h,!0)}{const r=t+8,o=s[t+6],a=r+n,u=o+n;let l=i,f=!1,h=!1;e?l||(f=e.has(a),h=e.has(u),l=!f&&!h):(f=!0,h=!0);const p=l||h;let y=!1;(l||f)&&(y=d(r,n,l));let m=!1;p&&(m=d(o,n,l));const x=y||m;if(x)for(let e=0;e<3;e++){const n=r+e,i=o+e,s=c[n],a=c[n+3],u=c[i],l=c[i+3];c[t+e]=s<u?s:u,c[t+e+3]=a>l?a:l}return x}}}function Ct(t,e,n,r,o){let i,s,a,c,u,l;const d=1/n.direction.x,f=1/n.direction.y,h=1/n.direction.z,p=n.origin.x,y=n.origin.y,m=n.origin.z;let x=e[t],g=e[t+3],b=e[t+1],v=e[t+3+1],w=e[t+2],B=e[t+3+2];return d>=0?(i=(x-p)*d,s=(g-p)*d):(i=(g-p)*d,s=(x-p)*d),f>=0?(a=(b-y)*f,c=(v-y)*f):(a=(v-y)*f,c=(b-y)*f),!(i>c||a>s)&&((a>i||isNaN(i))&&(i=a),(c<s||isNaN(s))&&(s=c),h>=0?(u=(w-m)*h,l=(B-m)*h):(u=(B-m)*h,l=(w-m)*h),!(i>l||u>s)&&((u>i||i!=i)&&(i=u),(l<s||s!=s)&&(s=l),i<=o&&s>=r))}function Vt(t,e,n,r,o,i,s){ct.setBuffer(t._roots[e]),Yt(0,t,n,r,o,i,s),ct.clearBuffer()}function Yt(t,e,n,r,o,i,s){const{float32Array:a,uint16Array:c,uint32Array:u}=ct,l=2*t;if(k(l,c)){!function(t,e,n,r,o,i,s,a){const{geometry:c,_indirectBuffer:u}=t;for(let l=r,d=r+o;l<d;l++)_t(c,e,n,l,i,s,a)}(e,n,r,z(t,u),R(l,c),o,i,s)}else{const c=H(t);Ct(c,a,r,i,s)&&Yt(c,e,n,r,o,i,s);const l=C(t,u);Ct(l,a,r,i,s)&&Yt(l,e,n,r,o,i,s)}}const Ot=["x","y","z"];function Wt(t,e,n,r,o,i){ct.setBuffer(t._roots[e]);const s=Gt(0,t,n,r,o,i);return ct.clearBuffer(),s}function Gt(t,e,n,r,o,i){const{float32Array:s,uint16Array:a,uint32Array:c}=ct;let u=2*t;if(k(u,a)){return function(t,e,n,r,o,i,s){const{geometry:a,_indirectBuffer:c}=t;let u=1/0,l=null;for(let d=r,f=r+o;d<f;d++){let t;t=_t(a,e,n,d,null,i,s),t&&t.distance<u&&(l=t,u=t.distance)}return l}(e,n,r,z(t,c),R(u,a),o,i)}{const a=V(t,c),u=Ot[a],l=r.direction[u]>=0;let d,f;l?(d=H(t),f=C(t,c)):(d=C(t,c),f=H(t));const h=Ct(d,s,r,o,i)?Gt(d,e,n,r,o,i):null;if(h){const t=h.point[u];if(l?t<=s[f+a]:t>=s[f+a+3])return h}const p=Ct(f,s,r,o,i)?Gt(f,e,n,r,o,i):null;return h&&p?h.distance<=p.distance?h:p:h||p||null}}const Lt=new o.NRn,Xt=new rt,Zt=new rt,jt=new o.kn4,Qt=new ot,Kt=new ot;function $t(t,e,n,r){ct.setBuffer(t._roots[e]);const o=Jt(0,t,n,r);return ct.clearBuffer(),o}function Jt(t,e,n,r,o=null){const{float32Array:i,uint16Array:s,uint32Array:a}=ct;let c=2*t;null===o&&(n.boundingBox||n.computeBoundingBox(),Qt.set(n.boundingBox.min,n.boundingBox.max,r),o=Qt);if(!k(c,s)){const s=t+8,c=a[t+6];A(s,i,Lt);if(o.intersectsBox(Lt)&&Jt(s,e,n,r,o))return!0;A(c,i,Lt);return!!(o.intersectsBox(Lt)&&Jt(c,e,n,r,o))}{const o=e.geometry,u=o.index,l=o.attributes.position,d=n.index,f=n.attributes.position,h=z(t,a),p=R(c,s);if(jt.copy(r).invert(),n.boundsTree){A(t,i,Kt),Kt.matrix.copy(jt),Kt.needsUpdate=!0;return n.boundsTree.shapecast({intersectsBounds:t=>Kt.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(r),t.b.applyMatrix4(r),t.c.applyMatrix4(r),t.needsUpdate=!0;for(let e=3*h,n=3*(p+h);e<n;e+=3)if(Dt(Zt,e,u,l),Zt.needsUpdate=!0,t.intersectsTriangle(Zt))return!0;return!1}})}for(let t=3*h,e=3*(p+h);t<e;t+=3){Dt(Xt,t,u,l),Xt.a.applyMatrix4(jt),Xt.b.applyMatrix4(jt),Xt.c.applyMatrix4(jt),Xt.needsUpdate=!0;for(let t=0,e=d.count;t<e;t+=3)if(Dt(Zt,t,d,f),Zt.needsUpdate=!0,Xt.intersectsTriangle(Zt))return!0}}}const te=new o.kn4,ee=new ot,ne=new ot,re=new o.Pq0,oe=new o.Pq0,ie=new o.Pq0,se=new o.Pq0;function ae(t,e,n,r={},o={},i=0,s=1/0){e.boundingBox||e.computeBoundingBox(),ee.set(e.boundingBox.min,e.boundingBox.max,n),ee.needsUpdate=!0;const a=t.geometry,c=a.attributes.position,u=a.index,l=e.attributes.position,d=e.index,f=at.getPrimitive(),h=at.getPrimitive();let p=re,y=oe,m=null,x=null;o&&(m=ie,x=se);let b=1/0,v=null,w=null;return te.copy(n).invert(),ne.matrix.copy(te),t.shapecast({boundsTraverseOrder:t=>ee.distanceToBox(t),intersectsBounds:(t,e,n)=>n<b&&n<s&&(e&&(ne.min.copy(t.min),ne.max.copy(t.max),ne.needsUpdate=!0),!0),intersectsRange:(t,r)=>{if(e.boundsTree){return e.boundsTree.shapecast({boundsTraverseOrder:t=>ne.distanceToBox(t),intersectsBounds:(t,e,n)=>n<b&&n<s,intersectsRange:(e,o)=>{for(let s=e,a=e+o;s<a;s++){Dt(h,3*s,d,l),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let e=t,n=t+r;e<n;e++){Dt(f,3*e,u,c),f.needsUpdate=!0;const t=f.distanceToTriangle(h,p,m);if(t<b&&(y.copy(p),x&&x.copy(m),b=t,v=e,w=s),t<i)return!0}}}})}for(let o=0,s=g(e);o<s;o++){Dt(h,3*o,d,l),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let e=t,n=t+r;e<n;e++){Dt(f,3*e,u,c),f.needsUpdate=!0;const t=f.distanceToTriangle(h,p,m);if(t<b&&(y.copy(p),x&&x.copy(m),b=t,v=e,w=o),t<i)return!0}}}}),at.releasePrimitive(f),at.releasePrimitive(h),b===1/0?null:(r.point?r.point.copy(y):r.point=y.clone(),r.distance=b,r.faceIndex=v,o&&(o.point?o.point.copy(x):o.point=x.clone(),o.point.applyMatrix4(te),y.applyMatrix4(te),o.distance=y.sub(o.point).length(),o.faceIndex=w),r)}function ce(t,e,n,r,o,i,s){const{geometry:a}=n,{index:c}=a,u=a.attributes.position;for(let l=t,d=e+t;l<d;l++){let t;if(t=n.resolveTriangleIndex(l),Dt(s,3*t,c,u),s.needsUpdate=!0,r(s,t,o,i))return!0}return!1}function ue(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const n=t.geometry,r=n.index?n.index.array:null,o=n.attributes.position;let i,s,a,c,u=0;const l=t._roots;for(let f=0,h=l.length;f<h;f++)i=l[f],s=new Uint32Array(i),a=new Uint16Array(i),c=new Float32Array(i),d(0,u),u+=i.byteLength;function d(n,i,u=!1){const l=2*n;if(a[l+15]===p){const e=s[n+6];let i=1/0,u=1/0,d=1/0,f=-1/0,h=-1/0,p=-1/0;for(let n=e,s=e+a[l+14];n<s;n++){const e=3*t.resolveTriangleIndex(n);for(let t=0;t<3;t++){let n=e+t;n=r?r[n]:n;const s=o.getX(n),a=o.getY(n),c=o.getZ(n);s<i&&(i=s),s>f&&(f=s),a<u&&(u=a),a>h&&(h=a),c<d&&(d=c),c>p&&(p=c)}}return(c[n+0]!==i||c[n+1]!==u||c[n+2]!==d||c[n+3]!==f||c[n+4]!==h||c[n+5]!==p)&&(c[n+0]=i,c[n+1]=u,c[n+2]=d,c[n+3]=f,c[n+4]=h,c[n+5]=p,!0)}{const t=n+8,r=s[n+6],o=t+i,a=r+i;let l=u,f=!1,h=!1;e?l||(f=e.has(o),h=e.has(a),l=!f&&!h):(f=!0,h=!0);const p=l||h;let y=!1;(l||f)&&(y=d(t,i,l));let m=!1;p&&(m=d(r,i,l));const x=y||m;if(x)for(let e=0;e<3;e++){const o=t+e,i=r+e,s=c[o],a=c[o+3],u=c[i],l=c[i+3];c[n+e]=s<u?s:u,c[n+e+3]=a>l?a:l}return x}}}function le(t,e,n,r,o,i,s){ct.setBuffer(t._roots[e]),de(0,t,n,r,o,i,s),ct.clearBuffer()}function de(t,e,n,r,o,i,s){const{float32Array:a,uint16Array:c,uint32Array:u}=ct,l=2*t;if(k(l,c)){!function(t,e,n,r,o,i,s,a){const{geometry:c,_indirectBuffer:u}=t;for(let l=r,d=r+o;l<d;l++)_t(c,e,n,u?u[l]:l,i,s,a)}(e,n,r,z(t,u),R(l,c),o,i,s)}else{const c=H(t);Ct(c,a,r,i,s)&&de(c,e,n,r,o,i,s);const l=C(t,u);Ct(l,a,r,i,s)&&de(l,e,n,r,o,i,s)}}const fe=["x","y","z"];function he(t,e,n,r,o,i){ct.setBuffer(t._roots[e]);const s=pe(0,t,n,r,o,i);return ct.clearBuffer(),s}function pe(t,e,n,r,o,i){const{float32Array:s,uint16Array:a,uint32Array:c}=ct;let u=2*t;if(k(u,a)){return function(t,e,n,r,o,i,s){const{geometry:a,_indirectBuffer:c}=t;let u=1/0,l=null;for(let d=r,f=r+o;d<f;d++){let t;t=_t(a,e,n,c?c[d]:d,null,i,s),t&&t.distance<u&&(l=t,u=t.distance)}return l}(e,n,r,z(t,c),R(u,a),o,i)}{const a=V(t,c),u=fe[a],l=r.direction[u]>=0;let d,f;l?(d=H(t),f=C(t,c)):(d=C(t,c),f=H(t));const h=Ct(d,s,r,o,i)?pe(d,e,n,r,o,i):null;if(h){const t=h.point[u];if(l?t<=s[f+a]:t>=s[f+a+3])return h}const p=Ct(f,s,r,o,i)?pe(f,e,n,r,o,i):null;return h&&p?h.distance<=p.distance?h:p:h||p||null}}const ye=new o.NRn,me=new rt,xe=new rt,ge=new o.kn4,be=new ot,ve=new ot;function we(t,e,n,r){ct.setBuffer(t._roots[e]);const o=Be(0,t,n,r);return ct.clearBuffer(),o}function Be(t,e,n,r,o=null){const{float32Array:i,uint16Array:s,uint32Array:a}=ct;let c=2*t;null===o&&(n.boundingBox||n.computeBoundingBox(),be.set(n.boundingBox.min,n.boundingBox.max,r),o=be);if(!k(c,s)){const s=t+8,c=a[t+6];A(s,i,ye);if(o.intersectsBox(ye)&&Be(s,e,n,r,o))return!0;A(c,i,ye);return!!(o.intersectsBox(ye)&&Be(c,e,n,r,o))}{const o=e.geometry,u=o.index,l=o.attributes.position,d=n.index,f=n.attributes.position,h=z(t,a),p=R(c,s);if(ge.copy(r).invert(),n.boundsTree){A(t,i,ve),ve.matrix.copy(ge),ve.needsUpdate=!0;return n.boundsTree.shapecast({intersectsBounds:t=>ve.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(r),t.b.applyMatrix4(r),t.c.applyMatrix4(r),t.needsUpdate=!0;for(let n=h,r=p+h;n<r;n++)if(Dt(xe,3*e.resolveTriangleIndex(n),u,l),xe.needsUpdate=!0,t.intersectsTriangle(xe))return!0;return!1}})}for(let t=h,n=p+h;t<n;t++){const n=e.resolveTriangleIndex(t);Dt(me,3*n,u,l),me.a.applyMatrix4(ge),me.b.applyMatrix4(ge),me.c.applyMatrix4(ge),me.needsUpdate=!0;for(let t=0,e=d.count;t<e;t+=3)if(Dt(xe,t,d,f),xe.needsUpdate=!0,me.intersectsTriangle(xe))return!0}}}const Ae=new o.kn4,Te=new ot,Pe=new ot,Me=new o.Pq0,Ie=new o.Pq0,Se=new o.Pq0,_e=new o.Pq0;function De(t,e,n,r={},o={},i=0,s=1/0){e.boundingBox||e.computeBoundingBox(),Te.set(e.boundingBox.min,e.boundingBox.max,n),Te.needsUpdate=!0;const a=t.geometry,c=a.attributes.position,u=a.index,l=e.attributes.position,d=e.index,f=at.getPrimitive(),h=at.getPrimitive();let p=Me,y=Ie,m=null,x=null;o&&(m=Se,x=_e);let b=1/0,v=null,w=null;return Ae.copy(n).invert(),Pe.matrix.copy(Ae),t.shapecast({boundsTraverseOrder:t=>Te.distanceToBox(t),intersectsBounds:(t,e,n)=>n<b&&n<s&&(e&&(Pe.min.copy(t.min),Pe.max.copy(t.max),Pe.needsUpdate=!0),!0),intersectsRange:(r,o)=>{if(e.boundsTree){const a=e.boundsTree;return a.shapecast({boundsTraverseOrder:t=>Pe.distanceToBox(t),intersectsBounds:(t,e,n)=>n<b&&n<s,intersectsRange:(e,s)=>{for(let g=e,B=e+s;g<B;g++){const e=a.resolveTriangleIndex(g);Dt(h,3*e,d,l),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let n=r,s=r+o;n<s;n++){const e=t.resolveTriangleIndex(n);Dt(f,3*e,u,c),f.needsUpdate=!0;const r=f.distanceToTriangle(h,p,m);if(r<b&&(y.copy(p),x&&x.copy(m),b=r,v=n,w=g),r<i)return!0}}}})}for(let s=0,a=g(e);s<a;s++){Dt(h,3*s,d,l),h.a.applyMatrix4(n),h.b.applyMatrix4(n),h.c.applyMatrix4(n),h.needsUpdate=!0;for(let e=r,n=r+o;e<n;e++){const n=t.resolveTriangleIndex(e);Dt(f,3*n,u,c),f.needsUpdate=!0;const r=f.distanceToTriangle(h,p,m);if(r<b&&(y.copy(p),x&&x.copy(m),b=r,v=e,w=s),r<i)return!0}}}}),at.releasePrimitive(f),at.releasePrimitive(h),b===1/0?null:(r.point?r.point.copy(y):r.point=y.clone(),r.distance=b,r.faceIndex=v,o&&(o.point?o.point.copy(x):o.point=x.clone(),o.point.applyMatrix4(Ae),y.applyMatrix4(Ae),o.distance=y.sub(o.point).length(),o.faceIndex=w),r)}function qe(){return"undefined"!=typeof SharedArrayBuffer}const Fe=new ct.constructor,Ne=new ct.constructor,Ue=new it((()=>new o.NRn)),Ee=new o.NRn,ke=new o.NRn,ze=new o.NRn,Re=new o.NRn;let He=!1;function Ce(t,e,n,r,o,i=0,s=0,a=0,c=0,u=null,l=!1){let d,f;l?(d=Ne,f=Fe):(d=Fe,f=Ne);const h=d.float32Array,p=d.uint32Array,y=d.uint16Array,m=f.float32Array,x=f.uint32Array,g=f.uint16Array,b=2*e,v=k(2*t,y),w=k(b,g);let B=!1;if(w&&v)B=l?o(z(e,x),R(2*e,g),z(t,p),R(2*t,y),c,s+e,a,i+t):o(z(t,p),R(2*t,y),z(e,x),R(2*e,g),a,i+t,c,s+e);else if(w){const u=Ue.getPrimitive();A(e,m,u),u.applyMatrix4(n);const d=H(t),f=C(t,p);A(d,h,Ee),A(f,h,ke);const y=u.intersectsBox(Ee),x=u.intersectsBox(ke);B=y&&Ce(e,d,r,n,o,s,i,c,a+1,u,!l)||x&&Ce(e,f,r,n,o,s,i,c,a+1,u,!l),Ue.releasePrimitive(u)}else{const d=H(e),f=C(e,x);A(d,m,ze),A(f,m,Re);const y=u.intersectsBox(ze),g=u.intersectsBox(Re);if(y&&g)B=Ce(t,d,n,r,o,i,s,a,c+1,u,l)||Ce(t,f,n,r,o,i,s,a,c+1,u,l);else if(y)if(v)B=Ce(t,d,n,r,o,i,s,a,c+1,u,l);else{const e=Ue.getPrimitive();e.copy(ze).applyMatrix4(n);const u=H(t),f=C(t,p);A(u,h,Ee),A(f,h,ke);const y=e.intersectsBox(Ee),m=e.intersectsBox(ke);B=y&&Ce(d,u,r,n,o,s,i,c,a+1,e,!l)||m&&Ce(d,f,r,n,o,s,i,c,a+1,e,!l),Ue.releasePrimitive(e)}else if(g)if(v)B=Ce(t,f,n,r,o,i,s,a,c+1,u,l);else{const e=Ue.getPrimitive();e.copy(Re).applyMatrix4(n);const u=H(t),d=C(t,p);A(u,h,Ee),A(d,h,ke);const y=e.intersectsBox(Ee),m=e.intersectsBox(ke);B=y&&Ce(f,u,r,n,o,s,i,c,a+1,e,!l)||m&&Ce(f,d,r,n,o,s,i,c,a+1,e,!l),Ue.releasePrimitive(e)}}return B}const Ve=new ot,Ye=new o.NRn,Oe={strategy:i,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class We{static serialize(t,e={}){e={cloneBuffers:!0,...e};const n=t.geometry,r=t._roots,o=t._indirectBuffer,i=n.getIndex();let s;return s=e.cloneBuffers?{roots:r.map((t=>t.slice())),index:i?i.array.slice():null,indirectBuffer:o?o.slice():null}:{roots:r,index:i?i.array:null,indirectBuffer:o},s}static deserialize(t,e,n={}){n={setIndex:!0,indirect:Boolean(t.indirectBuffer),...n};const{index:r,roots:i,indirectBuffer:s}=t,a=new We(e,{...n,[m]:!0});if(a._roots=i,a._indirectBuffer=s||null,n.setIndex){const n=e.getIndex();if(null===n){const n=new o.THS(t.index,1,!1);e.setIndex(n)}else n.array!==r&&(n.array.set(r),n.needsUpdate=!0)}return a}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if((e=Object.assign({...Oe,[m]:!1},e)).useSharedArrayBuffer&&!qe())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[m]||(K(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new o.NRn))),this.resolveTriangleIndex=e.indirect?t=>this._indirectBuffer[t]:t=>t}refit(t=null){return(this.indirect?ue:Ht)(this,t)}traverse(t,e=0){const n=this._roots[e],r=new Uint32Array(n),o=new Uint16Array(n);!function e(i,s=0){const a=2*i,c=o[a+15]===p;if(c){const e=r[i+6],u=o[a+14];t(s,c,new Float32Array(n,4*i,6),e,u)}else{const o=i+8,a=r[i+6],u=r[i+7];t(s,c,new Float32Array(n,4*i,6),u)||(e(o,s+1),e(a,s+1))}}(0)}raycast(t,e=o.hB5,n=0,r=1/0){const i=this._roots,s=this.geometry,a=[],c=e.isMaterial,u=Array.isArray(e),l=s.groups,d=c?e.side:e,f=this.indirect?le:Vt;for(let o=0,h=i.length;o<h;o++){const i=u?e[l[o].materialIndex].side:d,s=a.length;if(f(this,o,i,t,a,n,r),u){const t=l[o].materialIndex;for(let e=s,n=a.length;e<n;e++)a[e].face.materialIndex=t}}return a}raycastFirst(t,e=o.hB5,n=0,r=1/0){const i=this._roots,s=this.geometry,a=e.isMaterial,c=Array.isArray(e);let u=null;const l=s.groups,d=a?e.side:e,f=this.indirect?he:Wt;for(let o=0,h=i.length;o<h;o++){const i=f(this,o,c?e[l[o].materialIndex].side:d,t,n,r);null!=i&&(null==u||i.distance<u.distance)&&(u=i,c&&(i.face.materialIndex=l[o].materialIndex))}return u}intersectsGeometry(t,e){let n=!1;const r=this._roots,o=this.indirect?we:$t;for(let i=0,s=r.length;i<s&&(n=o(this,i,t,e),!n);i++);return n}shapecast(t){const e=at.getPrimitive(),n=this.indirect?ce:Rt;let{boundsTraverseOrder:r,intersectsBounds:o,intersectsRange:i,intersectsTriangle:s}=t;if(i&&s){const t=i;i=(r,o,i,a,c)=>!!t(r,o,i,a,c)||n(r,o,this,s,i,a,e)}else i||(i=s?(t,r,o,i)=>n(t,r,this,s,o,i,e):(t,e,n)=>n);let a=!1,c=0;const u=this._roots;for(let l=0,d=u.length;l<d;l++){const t=u[l];if(a=ht(this,l,o,i,r,c),a)break;c+=t.byteLength}return at.releasePrimitive(e),a}bvhcast(t,e,n){let{intersectsRanges:r,intersectsTriangles:i}=n;const s=at.getPrimitive(),a=this.geometry.index,c=this.geometry.attributes.position,u=this.indirect?t=>{const e=this.resolveTriangleIndex(t);Dt(s,3*e,a,c)}:t=>{Dt(s,3*t,a,c)},l=at.getPrimitive(),d=t.geometry.index,f=t.geometry.attributes.position,h=t.indirect?e=>{const n=t.resolveTriangleIndex(e);Dt(l,3*n,d,f)}:t=>{Dt(l,3*t,d,f)};if(i){const t=(t,n,r,o,a,c,d,f)=>{for(let p=r,y=r+o;p<y;p++){h(p),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let e=t,r=t+n;e<r;e++)if(u(e),s.needsUpdate=!0,i(s,l,e,p,a,c,d,f))return!0}return!1};if(r){const e=r;r=function(n,r,o,i,s,a,c,u){return!!e(n,r,o,i,s,a,c,u)||t(n,r,o,i,s,a,c,u)}}else r=t}return function(t,e,n,r){if(He)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");He=!0;const i=t._roots,s=e._roots;let a,c=0,u=0;const l=(new o.kn4).copy(n).invert();for(let o=0,d=i.length;o<d;o++){Fe.setBuffer(i[o]),u=0;const t=Ue.getPrimitive();A(0,Fe.float32Array,t),t.applyMatrix4(l);for(let e=0,o=s.length;e<o&&(Ne.setBuffer(s[e]),a=Ce(0,0,n,l,r,c,u,0,0,t),Ne.clearBuffer(),u+=s[e].length,!a);e++);if(Ue.releasePrimitive(t),Fe.clearBuffer(),c+=i[o].length,a)break}return He=!1,a}(this,t,e,r)}intersectsBox(t,e){return Ve.set(t.min,t.max,e),Ve.needsUpdate=!0,this.shapecast({intersectsBounds:t=>Ve.intersectsBox(t),intersectsTriangle:t=>Ve.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},r={},o=0,i=1/0){return(this.indirect?De:ae)(this,t,e,n,r,o,i)}closestPointToPoint(t,e={},n=0,r=1/0){return function(t,e,n={},r=0,o=1/0){const i=r*r,s=o*o;let a=1/0,c=null;if(t.shapecast({boundsTraverseOrder:t=>(yt.copy(e).clamp(t.min,t.max),yt.distanceToSquared(e)),intersectsBounds:(t,e,n)=>n<a&&n<s,intersectsTriangle:(t,n)=>{t.closestPointToPoint(e,yt);const r=e.distanceToSquared(yt);return r<a&&(mt.copy(yt),a=r,c=n),r<i}}),a===1/0)return null;const u=Math.sqrt(a);return n.point?n.point.copy(mt):n.point=mt.clone(),n.distance=u,n.faceIndex=c,n}(this,t,e,n,r)}getBoundingBox(t){t.makeEmpty();return this._roots.forEach((e=>{A(0,new Float32Array(e),Ye),t.union(Ye)})),t}}const Ge=new o.NRn,Le=new o.kn4;class Xe extends o.B69{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}getVertexPosition(...t){return o.eaF.prototype.getVertexPosition.call(this,...t)}constructor(t,e,n=10,r=0){super(),this.material=e,this.geometry=new o.LoY,this.name="MeshBVHRootHelper",this.depth=n,this.displayParents=!1,this.bvh=t,this.displayEdges=!0,this._group=r}raycast(){}update(){const t=this.geometry,e=this.bvh,n=this._group;if(t.dispose(),this.visible=!1,e){const r=this.depth-1,i=this.displayParents;let s=0;e.traverse(((t,e)=>{if(t>=r||e)return s++,!0;i&&s++}),n);let a=0;const c=new Float32Array(24*s);let u,l;e.traverse(((t,e,n)=>{const o=t>=r||e;if(o||i){A(0,n,Ge);const{min:t,max:e}=Ge;for(let n=-1;n<=1;n+=2){const r=n<0?t.x:e.x;for(let n=-1;n<=1;n+=2){const o=n<0?t.y:e.y;for(let n=-1;n<=1;n+=2){const i=n<0?t.z:e.z;c[a+0]=r,c[a+1]=o,c[a+2]=i,a+=3}}}return o}}),n),l=this.displayEdges?new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7]):new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7]),u=c.length>65535?new Uint32Array(l.length*s):new Uint16Array(l.length*s);const d=l.length;for(let t=0;t<s;t++){const e=8*t,n=t*d;for(let t=0;t<d;t++)u[n+t]=e+l[t]}t.setIndex(new o.THS(u,1,!1)),t.setAttribute("position",new o.THS(c,3,!1)),this.visible=!0}}}class Ze extends o.YJl{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(t){this.edgeMaterial.opacity=t,this.meshMaterial.opacity=t}constructor(t=null,e=null,n=10){t instanceof We&&(n=e||10,e=t,t=null),"number"==typeof e&&(n=e,e=null),super(),this.name="MeshBVHHelper",this.depth=n,this.mesh=t,this.bvh=e,this.displayParents=!1,this.displayEdges=!0,this.objectIndex=0,this._roots=[];const r=new o.mrM({color:65416,transparent:!0,opacity:.3,depthWrite:!1}),i=new o.V9B({color:65416,transparent:!0,opacity:.3,depthWrite:!1});i.color=r.color,this.edgeMaterial=r,this.meshMaterial=i,this.update()}update(){const t=this.mesh;let e=this.bvh||t.geometry.boundsTree||null;if(t.isBatchedMesh&&t.boundsTrees&&!e){const n=t._drawInfo[this.objectIndex];n&&(e=t.boundsTrees[n.geometryIndex]||e)}const n=e?e._roots.length:0;for(;this._roots.length>n;){const t=this._roots.pop();t.geometry.dispose(),this.remove(t)}for(let r=0;r<n;r++){const{depth:t,edgeMaterial:n,meshMaterial:o,displayParents:i,displayEdges:s}=this;if(r>=this._roots.length){const o=new Xe(e,n,t,r);this.add(o),this._roots.push(o)}const a=this._roots[r];a.bvh=e,a.depth=t,a.displayParents=i,a.displayEdges=s,a.material=s?n:o,a.update()}}updateMatrixWorld(...t){const e=this.mesh,n=this.parent;null!==e&&(e.updateWorldMatrix(!0,!1),n?this.matrix.copy(n.matrixWorld).invert().multiply(e.matrixWorld):this.matrix.copy(e.matrixWorld),(e.isInstancedMesh||e.isBatchedMesh)&&(e.getMatrixAt(this.objectIndex,Le),this.matrix.multiply(Le)),this.matrix.decompose(this.position,this.quaternion,this.scale)),super.updateMatrixWorld(...t)}copy(t){this.depth=t.depth,this.mesh=t.mesh,this.bvh=t.bvh,this.opacity=t.opacity,this.color.copy(t.color)}clone(){return new Ze(this.mesh,this.bvh,this.depth)}dispose(){this.edgeMaterial.dispose(),this.meshMaterial.dispose();const t=this.children;for(let e=0,n=t.length;e<n;e++)t[e].geometry.dispose()}}const je=new o.NRn,Qe=new o.NRn,Ke=new o.Pq0;function $e(t){switch(typeof t){case"number":return 8;case"string":return 2*t.length;case"boolean":return 4;default:return 0}}function Je(t){return t._roots.map(((e,n)=>function(t,e){const n={nodeCount:0,leafNodeCount:0,depth:{min:1/0,max:-1/0},tris:{min:1/0,max:-1/0},splits:[0,0,0],surfaceAreaScore:0};return t.traverse(((t,e,r,o,i)=>{const s=r[3]-r[0],a=r[4]-r[1],c=r[5]-r[2],u=2*(s*a+a*c+c*s);n.nodeCount++,e?(n.leafNodeCount++,n.depth.min=Math.min(t,n.depth.min),n.depth.max=Math.max(t,n.depth.max),n.tris.min=Math.min(i,n.tris.min),n.tris.max=Math.max(i,n.tris.max),n.surfaceAreaScore+=u*d*i):(n.splits[o]++,n.surfaceAreaScore+=u*f)}),e),n.tris.min===1/0&&(n.tris.min=0,n.tris.max=0),n.depth.min===1/0&&(n.depth.min=0,n.depth.max=0),n}(t,n)))}function tn(t){const e=new Set,n=[t];let r=0;for(;n.length;){const t=n.pop();if(!e.has(t)){e.add(t);for(let e in t){if(!Object.hasOwn(t,e))continue;r+=$e(e);const o=t[e];!o||"object"!=typeof o&&"function"!=typeof o?r+=$e(o):/(Uint|Int|Float)(8|16|32)Array/.test(o.constructor.name)||qe()&&o instanceof SharedArrayBuffer||o instanceof ArrayBuffer?r+=o.byteLength:n.push(o)}}}return r}function en(t){const e=t.geometry,n=[],r=e.index,o=e.getAttribute("position");let i=!0;return t.traverse(((e,s,a,c,u)=>{const l={depth:e,isLeaf:s,boundingData:a,offset:c,count:u};n[e]=l,A(0,a,je);const d=n[e-1];if(s)for(let n=c,f=c+u;n<f;n++){const e=t.resolveTriangleIndex(n);let s,a=3*e,c=3*e+1,u=3*e+2;r&&(a=r.getX(a),c=r.getX(c),u=r.getX(u)),Ke.fromBufferAttribute(o,a),s=je.containsPoint(Ke),Ke.fromBufferAttribute(o,c),s=s&&je.containsPoint(Ke),Ke.fromBufferAttribute(o,u),s=s&&je.containsPoint(Ke),console.assert(s,"Leaf bounds does not fully contain triangle."),i=i&&s}if(d){A(0,a,Qe);const t=Qe.containsBox(je);console.assert(t,"Parent bounds does not fully contain child."),i=i&&t}})),i}function nn(t){const e=[];return t.traverse(((t,n,r,i,s)=>{const a={bounds:A(0,r,new o.NRn)};n?(a.count=s,a.offset=i):(a.left=null,a.right=null),e[t]=a;const c=e[t-1];c&&(null===c.left?c.left=a:c.right=a)})),e[0]}function rn(t,e,n){return null===t?null:(t.point.applyMatrix4(e.matrixWorld),t.distance=t.point.distanceTo(n.ray.origin),t.object=e,t)}const on=parseInt(o.sPf)>=166,sn=new o.RlV,an=new o.Pq0,cn=new o.kn4,un=o.eaF.prototype.raycast,ln=o.$Ed.prototype.raycast,dn=new o.Pq0,fn=new o.eaF,hn=[];function pn(t,e){this.isBatchedMesh?yn.call(this,t,e):mn.call(this,t,e)}function yn(t,e){if(this.boundsTrees){const n=this.boundsTrees,r=this._drawInfo||this._instanceInfo,i=this._drawRanges||this._geometryInfo,s=this.matrixWorld;fn.material=this.material,fn.geometry=this.geometry;const a=fn.geometry.boundsTree,c=fn.geometry.drawRange;null===fn.geometry.boundingSphere&&(fn.geometry.boundingSphere=new o.iyt);for(let o=0,u=r.length;o<u;o++){if(!this.getVisibleAt(o))continue;const a=r[o].geometryIndex;if(fn.geometry.boundsTree=n[a],this.getMatrixAt(o,fn.matrixWorld).premultiply(s),!fn.geometry.boundsTree){this.getBoundingBoxAt(a,fn.geometry.boundingBox),this.getBoundingSphereAt(a,fn.geometry.boundingSphere);const t=i[a];fn.geometry.setDrawRange(t.start,t.count)}fn.raycast(t,hn);for(let t=0,n=hn.length;t<n;t++){const n=hn[t];n.object=this,n.batchId=o,e.push(n)}hn.length=0}fn.geometry.boundsTree=a,fn.geometry.drawRange=c,fn.material=null,fn.geometry=null}else ln.call(this,t,e)}function mn(t,e){if(this.geometry.boundsTree){if(void 0===this.material)return;cn.copy(this.matrixWorld).invert(),sn.copy(t.ray).applyMatrix4(cn),dn.setFromMatrixScale(this.matrixWorld),an.copy(sn.direction).multiply(dn);const n=an.length(),r=t.near/n,o=t.far/n,i=this.geometry.boundsTree;if(!0===t.firstHitOnly){const n=rn(i.raycastFirst(sn,this.material,r,o),this,t);n&&e.push(n)}else{const n=i.raycast(sn,this.material,r,o);for(let r=0,o=n.length;r<o;r++){const o=rn(n[r],this,t);o&&e.push(o)}}}else un.call(this,t,e)}function xn(t={}){return this.boundsTree=new We(this,t),this.boundsTree}function gn(){this.boundsTree=null}function bn(t=-1,e={}){if(!on)throw new Error("BatchedMesh: Three r166+ is required to compute bounds trees.");e.indirect&&console.warn('"Indirect" is set to false because it is not supported for BatchedMesh.'),e={...e,indirect:!1,range:null};const n=this._drawRanges||this._geometryInfo,r=this._geometryCount;this.boundsTrees||(this.boundsTrees=new Array(r).fill(null));const o=this.boundsTrees;for(;o.length<r;)o.push(null);if(t<0){for(let t=0;t<r;t++)e.range=n[t],o[t]=new We(this.geometry,e);return o}return t<n.length&&(e.range=n[t],o[t]=new We(this.geometry,e)),o[t]||null}function vn(t=-1){t<0?this.boundsTrees.fill(null):t<this.boundsTree.length&&(this.boundsTrees[t]=null)}function wn(t){switch(t){case 1:return o.ZQM;case 2:return o.TkQ;case 3:case 4:return o.c90}}class Bn extends o.GYF{constructor(){super(),this.minFilter=o.hxR,this.magFilter=o.hxR,this.generateMipmaps=!1,this.overrideItemSize=null,this._forcedType=null}updateFrom(t){const e=this.overrideItemSize,n=t.itemSize,r=t.count;if(null!==e){if(n*r%e!=0)throw new Error("VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.");t.itemSize=e,t.count=r*n/e}const i=t.itemSize,s=t.count,a=t.normalized,c=t.array.constructor,u=c.BYTES_PER_ELEMENT;let l,d,f,h,p=this._forcedType,y=i;if(null===p)switch(c){case Float32Array:p=o.RQf;break;case Uint8Array:case Uint16Array:case Uint32Array:p=o.bkx;break;case Int8Array:case Int16Array:case Int32Array:p=o.Yuy}let m=function(t){switch(t){case 1:return"R";case 2:return"RG";case 3:case 4:return"RGBA"}throw new Error}(i);switch(p){case o.RQf:f=1,d=function(t){switch(t){case 1:return o.VT0;case 2:return o.paN;case 3:case 4:return o.GWd}}(i),a&&1===u?(h=c,m+="8",c===Uint8Array?l=o.OUM:(l=o.tJf,m+="_SNORM")):(h=Float32Array,m+="32F",l=o.RQf);break;case o.Yuy:m+=8*u+"I",f=a?Math.pow(2,8*c.BYTES_PER_ELEMENT-1):1,d=wn(i),1===u?(h=Int8Array,l=o.tJf):2===u?(h=Int16Array,l=o.fBL):(h=Int32Array,l=o.Yuy);break;case o.bkx:m+=8*u+"UI",f=a?Math.pow(2,8*c.BYTES_PER_ELEMENT-1):1,d=wn(i),1===u?(h=Uint8Array,l=o.OUM):2===u?(h=Uint16Array,l=o.cHt):(h=Uint32Array,l=o.bkx)}3!==y||d!==o.GWd&&d!==o.c90||(y=4);const x=Math.ceil(Math.sqrt(s))||1,g=new h(y*x*x),b=t.normalized;t.normalized=!1;for(let o=0;o<s;o++){const e=y*o;g[e]=t.getX(o)/f,i>=2&&(g[e+1]=t.getY(o)/f),i>=3&&(g[e+2]=t.getZ(o)/f,4===y&&(g[e+3]=1)),i>=4&&(g[e+3]=t.getW(o)/f)}t.normalized=b,this.internalFormat=m,this.format=d,this.type=l,this.image.width=x,this.image.height=x,this.image.data=g,this.needsUpdate=!0,this.dispose(),t.itemSize=n,t.count=r}}class An extends Bn{constructor(){super(),this._forcedType=o.bkx}}class Tn extends Bn{constructor(){super(),this._forcedType=o.Yuy}}class Pn extends Bn{constructor(){super(),this._forcedType=o.RQf}}class Mn{constructor(){this.index=new An,this.position=new Pn,this.bvhBounds=new o.GYF,this.bvhContents=new o.GYF,this._cachedIndexAttr=null,this.index.overrideItemSize=3}updateFrom(t){const{geometry:e}=t;if(function(t,e,n){const r=t._roots;if(1!==r.length)throw new Error("MeshBVHUniformStruct: Multi-root BVHs not supported.");const i=r[0],s=new Uint16Array(i),a=new Uint32Array(i),c=new Float32Array(i),u=i.byteLength/h,l=2*Math.ceil(Math.sqrt(u/2)),d=new Float32Array(4*l*l),f=Math.ceil(Math.sqrt(u)),p=new Uint32Array(2*f*f);for(let o=0;o<u;o++){const t=o*h/4,e=2*t,n=t;for(let r=0;r<3;r++)d[8*o+0+r]=c[n+0+r],d[8*o+4+r]=c[n+3+r];if(k(e,s)){const n=R(e,s),r=z(t,a),i=4294901760|n;p[2*o+0]=i,p[2*o+1]=r}else{const e=4*C(t,a)/h,n=V(t,a);p[2*o+0]=n,p[2*o+1]=e}}e.image.data=d,e.image.width=l,e.image.height=l,e.format=o.GWd,e.type=o.RQf,e.internalFormat="RGBA32F",e.minFilter=o.hxR,e.magFilter=o.hxR,e.generateMipmaps=!1,e.needsUpdate=!0,e.dispose(),n.image.data=p,n.image.width=f,n.image.height=f,n.format=o.TkQ,n.type=o.bkx,n.internalFormat="RG32UI",n.minFilter=o.hxR,n.magFilter=o.hxR,n.generateMipmaps=!1,n.needsUpdate=!0,n.dispose()}(t,this.bvhBounds,this.bvhContents),this.position.updateFrom(e.attributes.position),t.indirect){const n=t._indirectBuffer;if(null===this._cachedIndexAttr||this._cachedIndexAttr.count!==n.length)if(e.index)this._cachedIndexAttr=e.index.clone();else{const t=b(x(e));this._cachedIndexAttr=new o.THS(t,1,!1)}!function(t,e,n){const r=n.array,o=t.index?t.index.array:null;for(let i=0,s=e.length;i<s;i++){const t=3*i,n=3*e[i];for(let e=0;e<3;e++)r[t+e]=o?o[n+e]:n+e}}(e,n,this._cachedIndexAttr),this.index.updateFrom(this._cachedIndexAttr)}else this.index.updateFrom(e.index)}dispose(){const{index:t,position:e,bvhBounds:n,bvhContents:r}=this;t&&t.dispose(),e&&e.dispose(),n&&n.dispose(),r&&r.dispose()}}const In=new o.Pq0,Sn=new o.Pq0,_n=new o.Pq0,Dn=new o.IUQ,qn=new o.Pq0,Fn=new o.Pq0,Nn=new o.IUQ,Un=new o.IUQ,En=new o.kn4,kn=new o.kn4;function zn(t,e){if(!t&&!e)return;const n=t.count===e.count,r=t.normalized===e.normalized,o=t.array.constructor===e.array.constructor,i=t.itemSize===e.itemSize;if(!(n&&r&&o&&i))throw new Error}function Rn(t,e=null){const n=t.array.constructor,r=t.normalized,i=t.itemSize,s=null===e?t.count:e;return new o.THS(new n(i*s),i,r)}function Hn(t,e,n=0){if(t.isInterleavedBufferAttribute){const r=t.itemSize;for(let o=0,i=t.count;o<i;o++){const i=o+n;e.setX(i,t.getX(o)),r>=2&&e.setY(i,t.getY(o)),r>=3&&e.setZ(i,t.getZ(o)),r>=4&&e.setW(i,t.getW(o))}}else{const r=e.array,o=r.constructor,i=r.BYTES_PER_ELEMENT*t.itemSize*n;new o(r.buffer,i,t.array.length).set(t.array)}}function Cn(t,e,n){const r=t.elements,o=e.elements;for(let i=0,s=o.length;i<s;i++)r[i]+=o[i]*n}function Vn(t,e,n){const r=t.skeleton,o=t.geometry,i=r.bones,s=r.boneInverses;Nn.fromBufferAttribute(o.attributes.skinIndex,e),Un.fromBufferAttribute(o.attributes.skinWeight,e),En.elements.fill(0);for(let a=0;a<4;a++){const t=Un.getComponent(a);if(0!==t){const e=Nn.getComponent(a);kn.multiplyMatrices(i[e].matrixWorld,s[e]),Cn(En,kn,t)}}return En.multiply(t.bindMatrix).premultiply(t.bindMatrixInverse),n.transformDirection(En),n}function Yn(t,e,n,r,o){qn.set(0,0,0);for(let i=0,s=t.length;i<s;i++){const s=e[i],a=t[i];0!==s&&(Fn.fromBufferAttribute(a,r),n?qn.addScaledVector(Fn,s):qn.addScaledVector(Fn.sub(o),s))}o.add(qn)}class On{constructor(t){this.matrixWorld=new o.kn4,this.geometryHash=null,this.boneMatrices=null,this.primitiveCount=-1,this.mesh=t,this.update()}update(){const t=this.mesh,e=t.geometry,n=t.skeleton,r=(e.index?e.index.count:e.attributes.position.count)/3;if(this.matrixWorld.copy(t.matrixWorld),this.geometryHash=e.attributes.position.version,this.primitiveCount=r,n){n.boneTexture||n.computeBoneTexture(),n.update();const t=n.boneMatrices;this.boneMatrices&&this.boneMatrices.length===t.length?this.boneMatrices.set(t):this.boneMatrices=t.slice()}else this.boneMatrices=null}didChange(){const t=this.mesh,e=t.geometry,n=(e.index?e.index.count:e.attributes.position.count)/3;return!(this.matrixWorld.equals(t.matrixWorld)&&this.geometryHash===e.attributes.position.version&&function(t,e){if(null===t||null===e)return t===e;if(t.length!==e.length)return!1;for(let n=0,r=t.length;n<r;n++)if(t[n]!==e[n])return!1;return!0}(t.skeleton&&t.skeleton.boneMatrices||null,this.boneMatrices)&&this.primitiveCount===n)}}class Wn{constructor(t){Array.isArray(t)||(t=[t]);const e=[];t.forEach((t=>{t.traverseVisible((t=>{t.isMesh&&e.push(t)}))})),this.meshes=e,this.useGroups=!0,this.applyWorldTransforms=!0,this.attributes=["position","normal","color","tangent","uv","uv2"],this._intermediateGeometry=new Array(e.length).fill().map((()=>new o.LoY)),this._diffMap=new WeakMap}getMaterials(){const t=[];return this.meshes.forEach((e=>{Array.isArray(e.material)?t.push(...e.material):t.push(e.material)})),t}generate(t=new o.LoY){let e=[];const{meshes:n,useGroups:r,_intermediateGeometry:i,_diffMap:s}=this;for(let o=0,a=n.length;o<a;o++){const t=n[o],r=i[o],a=s.get(t);!a||a.didChange(t)?(this._convertToStaticGeometry(t,r),e.push(!1),a?a.update():s.set(t,new On(t))):e.push(!0)}if(0===i.length){t.setIndex(null);const e=t.attributes;for(const n in e)t.deleteAttribute(n);for(const n in this.attributes)t.setAttribute(this.attributes[n],new o.THS(new Float32Array(0),4,!1))}else!function(t,e={useGroups:!1,updateIndex:!1,skipAttributes:[]},n=new o.LoY){const r=null!==t[0].index,{useGroups:i=!1,updateIndex:s=!1,skipAttributes:a=[]}=e,c=new Set(Object.keys(t[0].attributes)),u={};let l=0;n.clearGroups();for(let o=0;o<t.length;++o){const e=t[o];let s=0;if(r!==(null!==e.index))throw new Error("StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");for(const t in e.attributes){if(!c.has(t))throw new Error('StaticGeometryGenerator: All geometries must have compatible attributes; make sure "'+t+'" attribute exists among all geometries, or in none of them.');void 0===u[t]&&(u[t]=[]),u[t].push(e.attributes[t]),s++}if(s!==c.size)throw new Error("StaticGeometryGenerator: Make sure all geometries have the same number of attributes.");if(i){let t;if(r)t=e.index.count;else{if(void 0===e.attributes.position)throw new Error("StaticGeometryGenerator: The geometry must have either an index or a position attribute");t=e.attributes.position.count}n.addGroup(l,t,o),l+=t}}if(r){let e=!1;if(!n.index){let r=0;for(let e=0;e<t.length;++e)r+=t[e].index.count;n.setIndex(new o.THS(new Uint32Array(r),1,!1)),e=!0}if(s||e){const e=n.index;let r=0,o=0;for(let n=0;n<t.length;++n){const i=t[n],s=i.index;if(!0!==a[n])for(let t=0;t<s.count;++t)e.setX(r,s.getX(t)+o),r++;o+=i.attributes.position.count}}}for(const o in u){const t=u[o];if(!(o in n.attributes)){let e=0;for(const n in t)e+=t[n].count;n.setAttribute(o,Rn(u[o][0],e))}const e=n.attributes[o];let r=0;for(let n=0,o=t.length;n<o;n++){const o=t[n];!0!==a[n]&&Hn(o,e,r),r+=o.count}}}(i,{useGroups:r,skipAttributes:e},t);for(const o in t.attributes)t.attributes[o].needsUpdate=!0;return t}_convertToStaticGeometry(t,e=new o.LoY){const n=t.geometry,r=this.applyWorldTransforms,i=this.attributes.includes("normal"),s=this.attributes.includes("tangent"),a=n.attributes,c=e.attributes;!e.index&&n.index&&(e.index=n.index.clone()),c.position||e.setAttribute("position",Rn(a.position)),i&&!c.normal&&a.normal&&e.setAttribute("normal",Rn(a.normal)),s&&!c.tangent&&a.tangent&&e.setAttribute("tangent",Rn(a.tangent)),zn(n.index,e.index),zn(a.position,c.position),i&&zn(a.normal,c.normal),s&&zn(a.tangent,c.tangent);const u=a.position,l=i?a.normal:null,d=s?a.tangent:null,f=n.morphAttributes.position,h=n.morphAttributes.normal,p=n.morphAttributes.tangent,y=n.morphTargetsRelative,m=t.morphTargetInfluences,x=new o.dwI;x.getNormalMatrix(t.matrixWorld),n.index&&e.index.array.set(n.index.array);for(let o=0,g=a.position.count;o<g;o++)In.fromBufferAttribute(u,o),l&&Sn.fromBufferAttribute(l,o),d&&(Dn.fromBufferAttribute(d,o),_n.fromBufferAttribute(d,o)),m&&(f&&Yn(f,m,y,o,In),h&&Yn(h,m,y,o,Sn),p&&Yn(p,m,y,o,_n)),t.isSkinnedMesh&&(t.applyBoneTransform(o,In),l&&Vn(t,o,Sn),d&&Vn(t,o,_n)),r&&In.applyMatrix4(t.matrixWorld),c.position.setXYZ(o,In.x,In.y,In.z),l&&(r&&Sn.applyNormalMatrix(x),c.normal.setXYZ(o,Sn.x,Sn.y,Sn.z)),d&&(r&&_n.transformDirection(t.matrixWorld),c.tangent.setXYZW(o,_n.x,_n.y,_n.z,Dn.w));for(const o in this.attributes){const t=this.attributes[o];"position"!==t&&"tangent"!==t&&"normal"!==t&&t in a&&(c[t]||e.setAttribute(t,Rn(a[t])),zn(a[t],c[t]),Hn(a[t],c[t]))}return t.matrixWorld.determinant()<0&&function(t){const{index:e,attributes:n}=t;if(e)for(let r=0,o=e.count;r<o;r+=3){const t=e.getX(r),n=e.getX(r+2);e.setX(r,n),e.setX(r+2,t)}else for(const r in n){const t=n[r],e=t.itemSize;for(let n=0,r=t.count;n<r;n+=3)for(let o=0;o<e;o++){const e=t.getComponent(n,o),r=t.getComponent(n+2,o);t.setComponent(n,o,r),t.setComponent(n+2,o,e)}}}(e),e}}const Gn="\n\n// A stack of uint32 indices can can store the indices for\n// a perfectly balanced tree with a depth up to 31. Lower stack\n// depth gets higher performance.\n//\n// However not all trees are balanced. Best value to set this to\n// is the trees max depth.\n#ifndef BVH_STACK_DEPTH\n#define BVH_STACK_DEPTH 60\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\n// Utilities\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n",Ln="\n\nfloat dot2( vec3 v ) {\n\n\treturn dot( v, v );\n\n}\n\n// https://www.shadertoy.com/view/ttfGWl\nvec3 closestPointToTriangle( vec3 p, vec3 v0, vec3 v1, vec3 v2, out vec3 barycoord ) {\n\n    vec3 v10 = v1 - v0;\n    vec3 v21 = v2 - v1;\n    vec3 v02 = v0 - v2;\n\n\tvec3 p0 = p - v0;\n\tvec3 p1 = p - v1;\n\tvec3 p2 = p - v2;\n\n    vec3 nor = cross( v10, v02 );\n\n    // method 2, in barycentric space\n    vec3  q = cross( nor, p0 );\n    float d = 1.0 / dot2( nor );\n    float u = d * dot( q, v02 );\n    float v = d * dot( q, v10 );\n    float w = 1.0 - u - v;\n\n\tif( u < 0.0 ) {\n\n\t\tw = clamp( dot( p2, v02 ) / dot2( v02 ), 0.0, 1.0 );\n\t\tu = 0.0;\n\t\tv = 1.0 - w;\n\n\t} else if( v < 0.0 ) {\n\n\t\tu = clamp( dot( p0, v10 ) / dot2( v10 ), 0.0, 1.0 );\n\t\tv = 0.0;\n\t\tw = 1.0 - u;\n\n\t} else if( w < 0.0 ) {\n\n\t\tv = clamp( dot( p1, v21 ) / dot2( v21 ), 0.0, 1.0 );\n\t\tw = 0.0;\n\t\tu = 1.0-v;\n\n\t}\n\n\tbarycoord = vec3( u, v, w );\n    return u * v1 + v * v2 + w * v0;\n\n}\n\nfloat distanceToTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// point and cut off range\n\tvec3 point, float closestDistanceSquared,\n\n\t// outputs\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord, inout float side, inout vec3 outPoint\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\t// get the closest point and barycoord\n\t\tvec3 closestPoint = closestPointToTriangle( point, a, b, c, localBarycoord );\n\t\tvec3 delta = point - closestPoint;\n\t\tfloat sqDist = dot2( delta );\n\t\tif ( sqDist < closestDistanceSquared ) {\n\n\t\t\t// set the output results\n\t\t\tclosestDistanceSquared = sqDist;\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = normalize( cross( a - b, b - c ) );\n\t\t\tbarycoord = localBarycoord;\n\t\t\toutPoint = closestPoint;\n\t\t\tside = sign( dot( faceNormal, delta ) );\n\n\t\t}\n\n\t}\n\n\treturn closestDistanceSquared;\n\n}\n\nfloat distanceSqToBounds( vec3 point, vec3 boundsMin, vec3 boundsMax ) {\n\n\tvec3 clampedPoint = clamp( point, boundsMin, boundsMax );\n\tvec3 delta = point - clampedPoint;\n\treturn dot( delta, delta );\n\n}\n\nfloat distanceSqToBVHNodeBoundsPoint( vec3 point, sampler2D bvhBounds, uint currNodeIndex ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn distanceSqToBounds( point, boundsMin, boundsMax );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\tbvhClosestPointToPoint(\t\tbvh,\t\tpoint, maxDistance, faceIndices, faceNormal, barycoord, side, outPoint\t)\t_bvhClosestPointToPoint(\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\t\tpoint, maxDistance, faceIndices, faceNormal, barycoord, side, outPoint\t)\n\nfloat _bvhClosestPointToPoint(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// point to check\n\tvec3 point, float maxDistance,\n\n\t// output variables\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout vec3 outPoint\n ) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat closestDistanceSquared = maxDistance * maxDistance;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, currNodeIndex );\n\t\tif ( boundsHitDistance > closestDistanceSquared ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\t\t\tclosestDistanceSquared = distanceToTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count, point, closestDistanceSquared,\n\n\t\t\t\t// outputs\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, outPoint\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\t\t\tbool leftToRight = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, leftIndex ) < distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, rightIndex );//rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn sqrt( closestDistanceSquared );\n\n}\n",Xn="\n\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n// Raycasting\nbool intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax, out float dist ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tdist = max( t0, 0.0 );\n\n\treturn t1 >= dist;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// outputs\n\tinout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nbool intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, sampler2D bvhBounds, uint currNodeIndex, out float dist ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax, dist );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\tbvhIntersectFirstHit(\t\tbvh,\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\t)\t_bvhIntersectFirstHit(\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\t)\n\nbool _bvhIntersectFirstHit(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables split into separate variables due to output precision\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = INFINITY;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance;\n\t\tif (\n\t\t\t! intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh_bvhBounds, currNodeIndex, boundsHitDistance )\n\t\t\t|| boundsHitDistance > triangleDistance\n\t\t) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count,\n\t\t\t\trayOrigin, rayDirection, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n",Zn="\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n",jn=Zn,Qn=Ln,Kn=`\n\t${Gn}\n\t${Xn}\n`}}]);